# Lab1

## 练习1

|  Aarch64 | x86 |
|---|---|
| 只能使用load/store指令访存 | 可以使用很多指令访存 |
| 算术指令只能操作寄存器或立即数 | 算术指令可以访问内存 |
| 拥有32个通用寄存器 | 拥有16个通用寄存器 |
| 用有四个栈指针 SP_EL0, SP_EL1, SP_EL2, SP_EL3 | 只有一个栈指针 %rsp |
| 三个程序状态寄存器 SPSR_EL1，SPSR_EL2，SPSR_EL3 | 一个EFLAGS |
| 返回地址保存在寄存器中 | 返回地址压栈 |
| 拥有四个特权级EL0-3，其中EL3等级最高 | 拥有两个特权级 Ring0 和 Ring3，其中Ring0等级最高 |


## 练习2

`_start` 起始于 0x80000 处，定义在文件 start.S 中。

## 练习3

在 start.S 中，`mpidr_el1`是当前所在的CPU，如果当前CPU不是cpu0的话会一直挂在`bl secondary_hang`中，而cpu0则会跳过两句挂起指令继续执行。

## 练习4

第二行：`a`先被填入了100、101、102、103，`c[0]`被填入了200，而之前`c`指向了`a`，所以`a[0]`被修改成了200。

第三行：`c`指向了`a`，所以对`c[1]`赋值会使`a[1]`同时改变，由于`c`和`a`都是指向长整型的指针，所以`*(c+2)`于`c[2]`等价，猜测`3[c]`与`c[3]`等价。

第四行：`c=c+1`将`c`指向了`a[1]`的位置，所以`a[1]`被写入了400。

第五行：`c = (long *) ((char *) c + 1);`把c指向了`(long)a+9`，对c赋值改变了内存布局：

|(long)a+x|+0|+1|+2|+3|+4|+5|+6|+7|+8|+9|
|---|---|---|---|---|---|---|---|---|---|---|
|before|90|01|00|00|00|00|00|00|2D|01|
|after|90|F4|01|00|00|00|00|00|00|01|

## 练习5

`.init`部分的LMA与VMA相同，`.text`部分的LMA与VMA不同。我的看法是LMA可以被看作是被加载到的物理地址，在`.init`节执行的时候CPU还是默认的物理寻址模式，所以LMA与VMA是相同的，`.init`节执行完毕后，CPU已经进入了虚拟寻址模式，所以`.text`的LMA（加载到的物理地址）与VMA（运行时的虚拟地址）是不同的。

## 练习6

先用n除以base赋给n，当n为零时即可得到数字一共有多少位，如果结果是零位，说明数字本身是0，这时直接令位数等于1。之后取余即可得到每一位的数字了。

## 练习7

栈初始化位于`_start`中，内核栈位于`0x88530`的位置上。先初始化一个全为0的数组`boot_cpu_stack`，再把它所在的地址赋给栈指针，就为栈留下了`sizeof(boot_cpu_stack)`大小的空间。

## 练习8

每次进入`test_backtrace`时，会有4个64位字被压入栈。地址从低到高分别是上一个函数的`frame pointer`、`return address`、上一个函数的第一个参数、变量`hex`所在地址（在`write_num`中用到的）。

## 练习9

上一个函数的参数会被放在当前函数的栈帧中，在当前帧指针的更低地址处，第一个参数放在最低地址处，由于16bytes对其而空出的区域可以填上无意义的数据。帧指针保存在`fp`位置处，返回地址保存在`fp+8`处。

## 练习10

由于LR、FP、Args相对帧指针的位置是固定的，只需要取帧指针再访问相应偏移量上的内容即可。

Bones：比较取到的Args与上一个FP，相等时说明参数已经全部取出了。
