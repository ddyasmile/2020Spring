# Homework4

## Q1

在单个处理器系统中，使用自旋锁会造成其他进程忙等待，造成了CPU时钟的浪费。而对于多处理器系统，当一个进程在一个处理器自旋时，另一个进程可以在另一个处理器上在其临界区内执行。

## Q2

偏向读者的读写锁，当之前的读者还没有读完时，后面的读者就又来了，这时的写者就会被推到后面，如果读者源源不断地到来，那么写者就会一直等待下去。

在偏向读者地读写锁地锁结构体中添加一项表示当前有多少个写者在等待以及它对应的锁（防止两个进程同时更新它），写者拿锁时，会将写者数加一，放锁时会将它减一，当写者数减为零时唤醒所有等待的读者；读者拿锁时要先检查写者数是否为零，如果大于零则放锁sleep。

## Q3

当四个核各占有一个资源时，还剩一个资源，所以总有一个核能拿到两个资源运行下去。

## Q4

atomic_FAA行中，多个核都要对lock->next进行读和写，当一个核写过该值以后，其他核的cache都会无效，导致速度变慢。lock->owner也存在这个问题，但是读的次数远大于写的次数，所以开销不明显。

## Q5

设置一个时间片，当锁在一个NUMA节点上被持有的时间超过它时，锁会被移到下一个NUMA节点上；也可以加入优先级概念，每个NUMA节点的优先级由其上等待锁的进程决定，太久没有拿到锁的NUMA节点的优先级会提高。

## Q6

需要在lock中成功拿到锁以后添加内存屏障，及时将锁已经被持有这一状态更新到内存中，避免其他对锁的读操作读到旧的值。